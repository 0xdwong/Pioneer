# Solidity — All About Runtime Errors





![img](https://miro.medium.com/v2/resize:fit:1400/0*sFgMGhTs2PeqQ10N)

photo by [Sigmund](https://unsplash.com/@sigmund) on Unsplash

> *This article is Part II of the* [*“All About Errors” sub-series*](https://medium.com/better-programming/solidity-all-about-errors-cb831ad0b840)*.*

After looking at Compile Time errors in Part I (errors generated by the Solidity compiler), we will now look in Part II at runtime errors (errors generated at the time you interact with a contract deployed on a live network).

As we will see, 4 main types of errors can be generated in Solidity: `Error(string)`, Panic(uint256), custom `error` and `invalid`. We will cover the rules and semantics of each of them in this article. Finally, we will have a quick glance at some potential predictions for the new error types that might be added to the Solidity programming language.

```
Table of content
- Common examples of errors in Solidity
- Types of Solidity errors
- Error(string) 
- Panic(uint256)
    - Panic Error - Example
    - Panic(uint256) error codes
- Custom Errors
    - How to define custom errors?
    - Why using custom errors over string errors?
    - Named parameters for custom errors
    - Natspec comments for custom errors
    - Custom Errors are part of the ABI
- Invalid
- Future Type of Errors in Solidity
```

# Common examples of errors in Solidity

Many scenarios exist where a runtime error could occur among the Solidity code of a contract.

Some of the standard runtime errors related to Solidity include:

- When `require()` is called with the arguments which result as false.
- When creating a contract using the `new` keyword fails, and the process does not end properly.
- When a codeless (`address.code.length`) contract is targeted to an external function. (be aware of the `isContract()` culprit when it is running through a `constructor`)
- When ethers (= `msg.value`) is sent while calling a public getter (`view`) or `pure` method from a contract.
- when ethers (= `msg.value` ) are sent to a function in a contract that is not marked as `payable` .
- When a condition in an `assert()` is `false`.
- When a zero-initialised variable of `function` type is called.
- When a large or negative value is converted to an `enum`.
- When accessing an array in an index which is too big or negative.

However, we will see among this list of cases that each case falls into a specific error category **depending on the cause of the error.**

# Types of Errors in Solidity

- `Error(string)` → triggered via the built-in functions `require` and `revert` .
- `Panic(uint256)` → triggered via the built-in function `assert` , or created by the compiler in certain situations.
- custom `error` → triggered via `revert CustomError()` .
- `invalid` opcode → triggered via assembly.

*Example 1:*

the `keccak256` hash of `Error(string)` is `0x**08c379a0**afcc32b1a39302f7cb8073359698411ab5fd6e3edb2c02c0b5fba8aa` .

If we keep the first 4 bytes, we obtain the error selector `**0x08c379a0**` **for** `**Error(string)**`**.**

*Example 2:*

The `keccak256` hash of `Panic(uint256)` is `0x**4e487b71**539e0164c9d29506cc725e49342bcac15e0927282bf30fedfe1c7268` .

If we keep the first 4 bytes, we obtain the error selector `**0x4e487b71**` **for** `**Panic(uint256)**`**.**

The table below summarises the different types of errors in Solidity.

<iframe src="https://jeancvllr.medium.com/media/2423c109d6810953ab91be60b5c46954" allowfullscreen="" frameborder="0" height="301" width="680" title="SolidityErrorsTable.md" class="ek n fk dy bg" scrolling="no" style="box-sizing: inherit; top: 0px; width: 680px; height: 301px; left: 0px;"></iframe>

Let’s look at the Solidity code sample to illustrate and better understand

<iframe src="https://jeancvllr.medium.com/media/57ffed8247e6cc7b301dec7239973869" allowfullscreen="" frameborder="0" height="1139" width="680" title="Code snippet to show the different type of Solidity errors when debugging their selector (first 4 bytes of keccak256 hash of the error type string)" class="ek n fk dy bg" scrolling="no" style="box-sizing: inherit; top: 0px; width: 680px; height: 1139px; left: 0px;"></iframe>

If we debug the transaction in Remix, we will see that at the time just before the opcode `REVERT` a 4 bytes value is pushed on the stack. This 4 bytes value corresponds to the selector of the error type being thrown.

![img](https://miro.medium.com/v2/resize:fit:1400/1*LIHu-8vKDjr8vBDDuhVZ8g.jpeg)

debugging in Remix to find the selector of each Solidity error type (credit: author)

# `Error(string)`

The built-in error `Error(string)` is used for *“revert with error message”*.

An `Error(string)` exception (with an error message provided in the `string` parameter) occurs in the following situations:

1. Calling `require(x, "error message")` where `x` evaluates to `false` , and you have provided an `error message` .
2. If you use `revert()` or `revert("description")`.
3. If you perform an external function call targeting a contract that contains no code.
4. If your contract receives Ether via a public function without a `payable` modifier (including the constructor and the fallback function).
5. If your contract receives Ether via a public getter function.

The provided `string` is abi-encoded as if it were a call to the function `Error(string)` .

# Panic(uint256)

When it comes to `Panic(uint256)` type of errors in Solidity, there is one and only rule to keep in mind:

> `Panic(uint256)` errors should not be present in bug-free code.

If you encounter a `Panic` type error while developing and testing your Solidity contract: **you should fix your code!**

A Panic error that occurs at runtime in a smart contract already deployed on a network is likely a sign of either a bug in the smart contract code or the smart contract design requirements not being completely fulfilled or correctly.

In such a case, the bug must be fixed within the Solidity code so that the smart contract does not run into the same Panic error again at runtime.

The Solidity docs highlight this even more.

> Properly functioning code should never create a Panic, not even on invalid external input.
>
> If this happens, then there is a bug in your contract which you should fix.

## Panic error — example

Let’s look at a real-world example of how a `Panic` error can occur and be fixed. Take a look at the Solidity code snippet below.

<iframe src="https://jeancvllr.medium.com/media/aa0b59fde6f14538964d87ede850fa45" allowfullscreen="" frameborder="0" height="391" width="680" title="PanicErrorExample.sol" class="ek n fk dy bg" scrolling="no" style="box-sizing: inherit; top: 0px; width: 680px; height: 391px; left: 0px;"></iframe>

This function as the name suggests counts the number of `0x00` zero bytes at the end of a `bytes32` data value.

As an example when providing the value below as a `data` parameter, it will return `4` :

```
data = 0xcafecafecafecafecafecafecafecafecafecafecafecafecafecafe00000000
result = 4
```

![img](https://miro.medium.com/v2/resize:fit:1400/1*dJods2z7MbQLNuzzmy0adw.png)

At first sight, this function appears to be harmless. Given an input data that ends with a certain number of `0x00` , we can be sure to obtain a result.

But don’t be fooled by this function! This function and it’s comment tell a lie! Let’s look closely again.

```
// CHECK each bytes of the key, starting from the end (right to left)
// Skip each empty bytes `0x00` to find the first non-empty byte
while (data[index] == 0x00) index--;
```

Although comments can be good in code, don’t be fooled by them. In fact, the 2nd comment line tells us a lie. We believe the function *“Skip”* `*0x00*` zero bytes. **But instead, it simply carries on counting**. The `while` loop can be read in plain English as:

```
// while the byte at `index` in the `data` param is not `0x00`,
// keep decrementing the `index` by -1
while (data[index] == 0x00) index--;
```

So what does that tell us? That tells us that we start from `index = 31`
and keep decrementing. But what happens if we provide the following value as `data` parameter to the function?

```
data = 0x0000000000000000000000000000000000000000000000000000000000000000
result = 32?
```

We should expect `32` as a result. But do we obtain this? Let’s try it out:

![img](https://miro.medium.com/v2/resize:fit:1400/1*jbXEiwVdimAxaXYeiwPbPg.png)

As we said, the code above **keeps counting,** so when `index` reaches `0` , trying to decrement it with `index--` will underflow and create a `Panic` error with the error code: `0x11`

Some language analysis tools can be useful to analyse Solidity source code and catch these `Panic` errors. Such tools include:

- [Slither](https://github.com/crytic/slither)
- [MythX](https://mythx.io/)

## Panic(uint256) error codes

A `Panic(uint256)` type of error throws an exception with a single argument: a `uint256` number representing a hex error code.

The table below list and describe each of these error codes.

| Error Code (as `uint256` hex number) | Description                                                  |
| ------------------------------------ | ------------------------------------------------------------ |
| `0x00`                               | Used for generic compiler inserted panics.                   |
| `0x01`                               | If you call `assert` with an argument that evaluates to `false`. |
| `0x11`                               | If an arithmetic operation results in underflow or overflow outside of an `unchecked { ... }` block. |
| `0x12`                               | If you divide or modulo by zero (e.g. `5 / 0 or 23 % 0`)     |
| `0x21`                               | If you convert a value that is too big or negative into an enum type. |
| `0x22`                               | If you access a storage byte array that is incorrectly encoded. |
| `0x31`                               | If you call `.pop()` on an empty array.                      |
| `0x32`                               | If you access an array, `bytesN` or an array slice at an out-of-bounds or negative index (i.e. `x[i]` where `i >= x.length` or `i < 0`). |
| `0x41`                               | If you allocate too much memory or create an array that is too large. |
| `0x51`                               | If you call a zero-initialized variable of internal function type. |





> **Note:** `*Panic(uint256)*` exceptions used to use the invalid opcode before Solidity 0.8.0, which would consume all the gas available. This is not the case anymore. Since the major release 0.8.x of Solidity, Panic(uint256) errors use the `*REVERT*` opcode.
>
> **Note 2:** if you discover a `*Panic*` error in an Open Source project (popular or not) project that has a Github repositories, you should either:
>
> \- get in contact with the development team and share the error and how to reproduce it.
>
> \- open an issue or a PR with the description and fixes.
>
> Depending on the nature of the Panic error, they can be source of bug bounties! So you have all the incentives to communicate with the development team while making the code of the protocol more robust and safer for all the other users!

# Custom Errors

Custom errors have been available [since version 0.8.4 of Solidity](https://github.com/ethereum/solidity/releases/tag/v0.8.4). They allow providing information about why an operation failed. They are returned to the caller of the function. Below is a basic example

```
error InsufficientBalance(uint256 requested, uint256 available);

// Sends an amount of existing coins
// from any caller to an address
function send(address receiver, uint amount) public {
    if (amount > balances[msg.sender]) {
      revert InsufficientBalance(amount, balances[msg.sender]);
    }
    
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    emit Sent(msg.sender, receiver, amount);
}
```

## How to define custom errors?

Custom errors are defined using the `error` statement, the same way as you would define an `event`.

They can be defined either at the contract or file levels.

```
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

error InsufficientBalance(uint256 requested, uint256 available);

contract CustomErrorExample {
    error NotAuthorised(address notAllowedCaller);
}
```

## Why use custom errors over string errors?

Custom errors present multiple advantages over revert reason strings:

- they reduce the size of your contract bytecode and therefore reduce the deployment cost of your smart contract.
- they allow passing dynamic data alongside the revert message.

Custom errors are usually much cheaper than string error messages like `require(condition, "error message")` or `revert("error message")` and will reduce the bytecode size of your contract.

## Named parameters for custom errors

Passing the named parameters to the error is possible in the same way as with function and events arguments. The named arguments can be written as an object, and the error params can be defined in any order.

This is useful to improve the readability of revert cases in your Solidity code. Often, customs `error` are defined far away from where they are used. This leads to finding where the error was imported and looking up the arguments.

Look for example at the example below for comparison. (I have removed the `error` definition at the top). Since we now have the named arguments of the custom error as an object and inlined, it becomes obvious which information the custom `error` provides while reverting.

```
// Sends an amount of existing coins
// from any caller to an address
function send(address receiver, uint amount) public {
    if (amount &gt; balances[msg.sender]) {
        revert InsufficientBalance({
            requested: amount,
            available: balances[msg.sender]
        });
    }
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    emit Sent(msg.sender, receiver, amount);
}
```

Currently, up to solc 0.8.19, it is not possible to use custom errors in combination with `require()` . Therefore, to use custom errors, you should use a syntax with an `if` statement that evaluates to false:

```
if (!condition) revert CustomError();
```

## Natspec comments for custom errors

A longer description of the custom error can be supplied via NatSpec comments. You can use the `@dev` and `@param` tags to describe the error and the parameters that are thrown alongside the error.

Below is an example from the Seaport Solidity repository, where the custom error `OrderAlreadyFilled` is documented using Natspec comments.

![img](https://miro.medium.com/v2/resize:fit:1400/1*FzFQzZj8H7c5QRqnPtak5g.png)

source: https://github.com/ProjectOpenSea/seaport/blob/4b2c048a52f99062176476c2e1b6068c07ca0ab8/contracts/interfaces/ConsiderationEventsAndErrors.sol#L78-L85

Using documentation generator tools, you can then generate documentation for your custom errors by parsing the Natspec comments.

## Custom Errors are part of the ABI

One important thing to notice is that custom errors are part of the contract JSON ABI generated by the `solc` compiler.

Below is an example of the JSON ABI generated in hardhat of the `LSP0ERC725Account` from the 

[LUKSO](https://medium.com/u/2376b006b57f?source=post_page-----57f22e8d6046--------------------------------)

 [*lsp-smart-contracts.*](https://github.com/lukso-network/lsp-smart-contracts)



![img](https://miro.medium.com/v2/resize:fit:1400/1*BdbNpkn71lYdbOo2fYZG0A.png)

[source: LUKSO lsp-smart-contracts repo on Github, file LSP0ERC725Account.sol](https://github.com/lukso-network/lsp-smart-contracts/blob/v0.8.1/contracts/LSP0ERC725Account/LSP0ERC725AccountCore.sol)

You can access the bytes4 selector of a custom error using the `.selector` syntax the same way as you would access the bytes4 selector of a function. So for instance: `CustomError.selector`

```
// SPDC-License-Identifier: Apache-2.0
pragma solidity 0.8.4;

error CustomError();
error InsufficientFunds(uint256 balance);

contract CustomErrorsContract {
    
    function getCustomErrorSelector() public pure returns (bytes4) {
        return CustomError.selector;
    }
    function getInsufficientFundsErrorSelector() public pure returns (bytes4) {
        return InsufficientFunds.selector;
    }
    
}
```

However, it is not possible to access the selector of a custom `error` in inline assembly.

Finally, you can retrieve the list of custom errors selectors using the `solc` compiler option `--hashes` since Solidity release v0.8.12

![img](https://miro.medium.com/v2/resize:fit:1400/1*pVhUOO7topKwTGvEWHGUQg.png)

Github release of Solidity v0.8.12 with compiler feature to generate error signatures (source: https://github.com/ethereum/solidity/releases/tag/v0.8.12)

# Invalid

The `invalid` opcode (instruction `0xfe`) can be used only in inline assembly. It is not available as a built-in function in Solidity.

Unlike the special function `require` and `revert` in Solidity that reverts the state changes but refunds all the remaining gas, the `invalid()` opcode instruction in assembly consumes all the remaining gas available in addition to reverting the transaction and all the state changes.

![img](https://miro.medium.com/v2/resize:fit:1400/1*Rg_1JZlfrG6ieADIOPJs3Q.png)

To use the `invalid` opcode, it must be used within an assembly block. The `invalid` instruction can be run with the parentheses as `invalid()` .

```
function runInvalid() public {
    assembly {
        invalid()
    }
}
```

Let’s look at an example of a real-world Solidity contract that uses `invalid` via inline assembly. It is used in a not so know contract from the OpenZeppelin contracts package: the `MinimalForwarder`.

This contract provides a basic forwarding function `execute(...)` that forwards a function call to a destination address.

Looking closely at line 67, you will see how the `invalid` opcode is used. You will also see the additional note in comments above lines 62–65 that emphasise that it does not return the remaining gas to the caller but instead consumes all of it.

![img](https://miro.medium.com/v2/resize:fit:1400/1*v3KvHaMLWxg642QH5g-wNQ.png)

[source: openzeppelin/contracts Github repo (v4.1.8), MinimalForwarder.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.2/contracts/metatx/MinimalForwarder.sol)

# Future Types of Errors in Solidity?

> **Note:** these are hypothesis based on current research in the Solidity Github repository at the time of writing (22/03/2023). These might change.

There are two potential future directions for error type in Solidity.

- introduce `Error(uint256)` with specific error codes for certain encoding/decoding functions from `abi.encode` and `abi.decode`
- Have `Panic` and `Error` error codes available in the global namespace of Solidity (the future `std` library).

![img](https://miro.medium.com/v2/resize:fit:1400/1*ccJ2-Ppzg5mBcC20ur6isg.png)

source: https://github.com/ethereum/solidity/issues/13869#issuecomment-1423021751

You can find more details about these current proposals in the discussion issues on the Github repository Solidity. See the links below:

 [Consider to encode certain reverts](https://github.com/ethereum/solidity/issues/11664) 



 [Unable to use `try`/`catch` to catch local reverts in extra code generated for high-level external](https://github.com/ethereum/solidity/issues/13869#issuecomment-1423021751)…

